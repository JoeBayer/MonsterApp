//----------------------------------------------------------------------------------------//
//----------------------------------------------------------------------------------------//
//--TO-DO-LIST----------------------------------------------------------------------------//
//----------------------------------------------------------------------------------------//
//----------------------------------------------------------------------------------------//

// Last Updated 6/29/16
// CHANGELOG
// 6/29/16
// - Changed Battles from 3v3 to 2v2
// - Changed the name of Helpers to Orbs
// - Updated section III to include orbs and monsters
// - Removed Section 3 due to the lack of a need for a finite state machine

KEY:
A - Designed and Implemented
X - Canceled

I.) How Do Battles Work?
II.) How Do You Ugrade Monsters?
III.) How Do You Get More Cards, Orbs and Monsters?
IV.) How Does Deck Building Work?

1.) Design and Implement Status
2.) Design and Implement Action Cards

A - 4.) Allow multiple monsters to fight on each side
	- allow user to choose which monster to attack
	- design and implement turn system based on speed and priority
5.) Design and Implement Player/Opponent Class
	- Includes Deck/Hand Manipulation
6.) Design and Implement Graphics
7.) Design and Implement easy Deck Building for User
8.) Design and Implement main game mode (tourney)

//----------------------------------------------------------------------------------------//
//--I.)-HOW-DO-BATTLES-WORK?--------------------------------------------------------------//
//----------------------------------------------------------------------------------------//
- Each player has two monsters on the field
- Each player starts with 3 action cards
- Battles switch between two phases
	- 1.) Monster Phase
	- 2.) Player Phase
MONSTER PHASE
- Monsters attack each other in an order based on their speed
PLAYER PHASE
- Both players draw a card
- The players each take the cards they want to play and put them face down in the order they want them to played (first is top, last is bottom)
	- A player can only add another card to a stack of cards to played if a previous card in the stack added actions
	- The standard amount of actions for each player starts at 1
- Both players reveal their first card (if they have one) at the same time. Both of these cards then activate their abilities.
	- This continues until both piles of face-down cards are empty
	- Damage Dealing and Status Dealing cards have a lower priority than other cards
		- EX: a protect and a damage card are played at the same time, the damage does not occur
		- EX: a paralysis guard is played at the same time as a paralyze card, the monster blocks paralysis
		- EX: a heal and damage card are played at the same time, the monster is healed then damaged

- Once both monsters on a player's team are defeated OR a player forfeits, the battle is over

//----------------------------------------------------------------------------------------//
//--II.)-HOW-DO-YOU-UPGRADE-MONSTERS?-----------------------------------------------------//
//----------------------------------------------------------------------------------------//
- Monsters are improved by earning currency for upgrades
	- Currency is earned through battling, playing through the story, and through real world money
- The player uses this currency to buy orbs, attack change, or evolve the monster
	- Orbs have a passive effect on the monster
		- Attaching a helper binds the helper and monster card together forever
			- Even after it evolves
	- Attack Change allows the monster to unlock another attack
		- The monster can only have one attack at a time, but the player can choose from the unlocked attacks
			- The unlocked attack slots carry over on to evolutions
	- Evolving a Monster increases its stats overall and possibly gives it a new set of attacks overall

//----------------------------------------------------------------------------------------//
//--III.)-HOW-DO-YOU-GET-MORE-CARDS,-ORBS,-AND-MONSTERS?----------------------------------//
//----------------------------------------------------------------------------------------//
- Once the player saves up enough currency, the player can buy booster packs
	- Booster packs contain five cards
		- at least one card must be above a certain rarity
- Once the player saves up enough currency, the player can get a bubble toy from an in-game toy machine for more Orbs
- Once the player saves up enough currency, the player can buy any of three daily monsters

//----------------------------------------------------------------------------------------//
//--IV.)-HOW-DOES-DECK-BUILDING-WORK?-----------------------------------------------------//
//----------------------------------------------------------------------------------------//
- Decks consist of only action cards
- Each deck has 40 cards
	- The number is lower because most trading card games have a larger variety of card types - we only have action cards
		- Pokemon TCG has 60 per deck
		- Magic has 60 per deck
		- Yu-Gi-Oh! has 40 - 60 per deck
- A player can build a deck using his or her set of action cards
	- A deck limit of 4 copies of a single card is imposed as a default unless otherwise noted


//----------------------------------------------------------------------------------------//
//--1.)-DESIGN-AND-IMPLEMENT-STATUS-------------------------------------------------------//
//----------------------------------------------------------------------------------------//

//--1a.)--//
//-- Other games with status--//
- Pokemon
	- has some great base ailments (poison, paralyzed sleep)
	- a few too many statuses that perform similar actions to other
	- anything involving evasion does not improve gameplay
		- increasing accuracy however, can be fun
- Final Fantasy (series)
	- too many statuses
	- some interesting status that buff/nerf available actions
- Earthbound
	- too many statues
		- however, these wide range of statuses help build even more character
		  into the game
	- a ton of interesting and bizarre statuses (asthma, cold, homesick)

//--1b.)--//
//--Examples of status ailments--//
- Poison / Plague / Bleeding
	- Take away 1/16 of total health each time the it is the monster's turn
- Paralyzed / Stun
	- 50% chance for monster to not attack
	- Speed is temporarily cut in half
- Sleeping 
	- Monster is asleep for 3 - 5 turn and cannot take action
- Berserk
	- Only activated when in critical condition
	- Monster's attack and speed are buffed
	- User cannot control who the berserker attacks
- Weird Transformation 
	- Transform a monster into a different monster
		- Zombie
		- Frog
		- Puppy
		- Bunny
		- Kitten
- Doom  
	- Monster will be discarded in 3 turns
- Haste
	- Increase number of attacks in a turn
- Charm
	- victim sometimes attacks for the opposing team
- Zombie
	- victim becomes a zombie and is hurt by healing actions
- Stop
	- unable to do anything until the condition is gone
- Confusion
	- 50% of the time the victim hurts itself or an ally
- Blindness
	- decrease accuracy of attacks
		- decreasing accuracy or increasing evasion aren't very fun

//--1c.)--//
//--Status ailments planned for this game--//
- Poison
- Paralysis
- Sleep
- Charm
- Transformation
- Berserk
- Doom
- Haste
- Slow

//----------------------------------------------------------------------------------------//
//--2.)-DESIGN-AND-IMPLEMENT-ACTION CARDS-------------------------------------------------//
//----------------------------------------------------------------------------------------//

//--1a.)--//
//--Examples of "Action Cards" in RPGs--//
- Basic Items in all RPGs
- Trap Cards and Defense Cards in Yu-Gi-Oh!
- Almost all cards in the board game "Dominion"
- Non Pokemon/Energy Cards from the Pokemon TCG
- Hearthstone Monster Card effects
- Held items in the Pokemon series
- Magic The Gathering Cards

//--1b.)--//
//--Possible Action Card Actions--//
- Draw 2
- Force Enemy to discard down to 7 cards
	- Force Enemy to discard down to 3 cards
- Pick a random card in opponents hand to discard
- Block an action card
- Replace cards in your hand that you don't want with an equal amount of random cards from your deck
- Any Effect, +n Action(s)
- +2 Actions
- Opponent reveals top three cards in deck
- Shuffle your deck
- Shuffle your opponent's deck
- Shuffle your opponent's hand into their deck and make them draw 4 cards
- Shuffle your hand into your deck and draw 5 cards
- Shuffle two cards into your hand and draw one card
- Discard your hand and take 7 cards from your deck
- Opponent reveals their hand
- Take two cards from your discard pile into your hand
- Draw until you have 7 cards
- Draw until you have the same amount of cards in your hand as your opponent (immediately discard this card after use)

- Increase monster(s) stats
- Protect Monster from damage (discard this card after one turn)
- Make monster(s) immune to gaining a specific status ailment
- Give status ailment/buff to a monster
- Damage a monster (immediately discard this card after use)
- Heal a monster (immediately discard this card after use)
- Heal the status of a monster (immediately discard this card after use)
- Block all action cards next turn (discard this card after one turn)
- Focus all enemy attacks on one of your monsters (discard this card after one turn)
- Half the damage done to a specific monster (put this card next to the monster your want to protect) (discard this card after one turn)
- Remove all action cards from your opponent's field (immediately discard this card after use)
- Make a monster immune to any changes (nerfs OR buffs)
- Remove an active action card from the field (immediately discard this card after use)

//--1c.)--//
//--Each card can have multiple effects--//
- To increase card variety and strategy, it would be beneficial from a design perspective to have action
cards that have multiple effects
	- These effects can either act together OR the player can choose which effect to use
		- This puts even more pressure on the player to play strategically and not just have the best monsters
- Effects that will be easy to tack on to to others in the same card:
	- +n Actions
	- Draw n cards
	- Discard n cards, draw n cards
	- Other player draws n cards
	- Shuffle Deck
	- Shuffle Opponent's deck
	- Discard n cards
	- Put a card from your hand into the bottom of your deck

//--1d.)--//
//--Pre-Code--//
- Class Hierarchy:
	- ACTION CARD (abstract class)
		- CARD1
		- CARD2
		- ETC...
-PSEUDO CODE:
class ActionCard
{
public:
	virtual void activate( Monster *e ) = 0;	// function that affects the monsters in battle
	string getName(){ return name; }	// ActionCard acessor functions
	string getDescr(){ return description; }
	void setName( string n ){ name = n; }	// ActionCard mutator functions
	void setDescr( string d ){ description = d; }
	
private:
	string name;
	string description
};

//----------------------------------------------------------------------------------------//
//--3.)-IMPLEMENT-OPPONENT-AND-ENEMONST-FINITE-STATE-MACHINES------------//
//----------------------------------------------------------------------------------------//

- States for enemy ai are listed in excel file under the design folder labeled "States"

struct Telegram;

template <class entity_type>
class State
{
public:

  virtual ~State(){}

  //this will execute when the state is entered
  virtual void Enter(entity_type*)=0;

  //this is the states normal update function
  virtual void Execute(entity_type*)=0;

  //this will execute when the state is exited. 
  virtual void Exit(entity_type*)=0;

  //this executes if the agent receives a message from the 
  //message dispatcher
  virtual bool OnMessage(entity_type*, const Telegram&)=0;
};
-------
template <class entity_type>
class StateMachine
{
private:

  //a pointer to the agent that owns this instance
  entity_type*          m_pOwner;

  State<entity_type>*   m_pCurrentState;
  
  //a record of the last state the agent was in
  State<entity_type>*   m_pPreviousState;

  //this is called every time the FSM is updated
  State<entity_type>*   m_pGlobalState;
  

public:

  StateMachine(entity_type* owner):m_pOwner(owner),
                                   m_pCurrentState(NULL),
                                   m_pPreviousState(NULL),
                                   m_pGlobalState(NULL)
  {}

  virtual ~StateMachine(){}

  //use these methods to initialize the FSM
  void SetCurrentState(State<entity_type>* s){m_pCurrentState = s;}
  void SetGlobalState(State<entity_type>* s) {m_pGlobalState = s;}
  void SetPreviousState(State<entity_type>* s){m_pPreviousState = s;}
  
  //call this to update the FSM
  void  Update()const
  {
    //if a global state exists, call its execute method, else do nothing
    if(m_pGlobalState)   m_pGlobalState->Execute(m_pOwner);

    //same for the current state
    if (m_pCurrentState) m_pCurrentState->Execute(m_pOwner);
  }

  bool  HandleMessage(const Telegram& msg)const
  {
    //first see if the current state is valid and that it can handle
    //the message
    if (m_pCurrentState && m_pCurrentState->OnMessage(m_pOwner, msg))
    {
      return true;
    }
  
    //if not, and if a global state has been implemented, send 
    //the message to the global state
    if (m_pGlobalState && m_pGlobalState->OnMessage(m_pOwner, msg))
    {
      return true;
    }

    return false;
  }

  //change to a new state
  void  ChangeState(State<entity_type>* pNewState)
  {
    assert(pNewState && "<StateMachine::ChangeState>:trying to assign null state to current");

    //keep a record of the previous state
    m_pPreviousState = m_pCurrentState;

    //call the exit method of the existing state
    m_pCurrentState->Exit(m_pOwner);

    //change state to the new state
    m_pCurrentState = pNewState;

    //call the entry method of the new state
    m_pCurrentState->Enter(m_pOwner);
  }

  //change state back to the previous state
  void  RevertToPreviousState()
  {
    ChangeState(m_pPreviousState);
  }

  //returns true if the current state's type is equal to the type of the
  //class passed as a parameter. 
  bool  isInState(const State<entity_type>& st)const
  {
    if (typeid(*m_pCurrentState) == typeid(st)) return true;
    return false;
  }

  State<entity_type>*  CurrentState()  const{return m_pCurrentState;}
  State<entity_type>*  GlobalState()   const{return m_pGlobalState;}
  State<entity_type>*  PreviousState() const{return m_pPreviousState;}

  //only ever used during debugging to grab the name of the current state
  std::string         GetNameOfCurrentState()const
  {
    std::string s(typeid(*m_pCurrentState).name());

    //remove the 'class ' part from the front of the string
    if (s.size() > 5)
    {
      s.erase(0, 6);
    }

    return s;
  }
};

//----------------------------------------------------------------------------------------//
//--4.)-ALLOW-MULTIPLE-MONSTERS-TO-FIGHT-ON-EACH-SIDE-------------------------------------//
//----------------------------------------------------------------------------------------//

You need to be able to choose which monster you would like to attack

All Monsters in a match (2V2) should be held in a few arrays
- Two Arrays for your monsters and your opponent's monsters
	- Used to display and attack specified target
- An array arranged in order of speed from highest to lowest
	- updates after each turn

Monster *playerArr[ 2 ];
Monster *oppArr[ 2 ];
Monster *turnOrder[ 4 ];

void updateTurnOrder();
	- check the speed of every monster and order them from fastest to slowest

//----------------------------------------------------------------------------------------//
//--5.)-DESIGN-AND-IMPLEMENT-PLAYER/OPPONENT-CLASS----------------------------------------//
//----------------------------------------------------------------------------------------//

-The Player Class handles all the info and functions that pertain to a player's deck order, 
	current hand, and current monsters

